/* tslint:disable */
/* eslint-disable */
/**
 * DeepVISS TAG
 * DeepVISS (Deep Vision Interoperability Specification Standard) allows several computer vision solutions to produce, consume and exchange events in the same format.
 *
 * The version of the OpenAPI document: 1.2.0
 * Contact: office@deepviss.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { exists, mapValues } from '../runtime';
import {
    InternalSubjectiveOpinion,
    InternalSubjectiveOpinionFromJSON,
    InternalSubjectiveOpinionFromJSONTyped,
    InternalSubjectiveOpinionToJSON,
} from './';

/**
 * 
 * @export
 * @interface Edge
 */
export interface Edge {
    /**
     * Need to find solution for unifying tag id's across taggers-collaborators.Alpha-numeric, unique id of tagged object
     * @type {string}
     * @memberof Edge
     */
    sourceTagId?: string;
    /**
     * Need to find solution for unifying tag id's across taggers-collaborators. Alpha-numeric, unique id of tagged object
     * @type {string}
     * @memberof Edge
     */
    destinationTagID?: string;
    /**
     * textBox id from inside sourceTag
     * @type {string}
     * @memberof Edge
     */
    sourceTextBoxId?: string;
    /**
     * textBox id from inside destinationTag
     * @type {string}
     * @memberof Edge
     */
    destinationTextBoxId?: string;
    /**
     * The type of the relationship between the two objects. Can be extended to discrete histogram of types. All types must belong to taxonomy or the challenge must allow for open-taxonomy.
     * @type {string}
     * @memberof Edge
     */
    edgeType?: string;
    /**
     * How much the edge can allow for the nodes to move without changing its length?
     * @type {number}
     * @memberof Edge
     */
    slack?: number;
    /**
     * How much the edge can extended or contracted?
     * @type {number}
     * @memberof Edge
     */
    elasticity?: number;
    /**
     * 
     * @type {InternalSubjectiveOpinion}
     * @memberof Edge
     */
    internalSubjectiveOpinion?: InternalSubjectiveOpinion;
}

export function EdgeFromJSON(json: any): Edge {
    return EdgeFromJSONTyped(json, false);
}

export function EdgeFromJSONTyped(json: any, ignoreDiscriminator: boolean): Edge {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        
        'sourceTagId': !exists(json, 'sourceTagId') ? undefined : json['sourceTagId'],
        'destinationTagID': !exists(json, 'destinationTagID') ? undefined : json['destinationTagID'],
        'sourceTextBoxId': !exists(json, 'sourceTextBoxId') ? undefined : json['sourceTextBoxId'],
        'destinationTextBoxId': !exists(json, 'destinationTextBoxId') ? undefined : json['destinationTextBoxId'],
        'edgeType': !exists(json, 'edgeType') ? undefined : json['edgeType'],
        'slack': !exists(json, 'slack') ? undefined : json['slack'],
        'elasticity': !exists(json, 'elasticity') ? undefined : json['elasticity'],
        'internalSubjectiveOpinion': !exists(json, 'internalSubjectiveOpinion') ? undefined : InternalSubjectiveOpinionFromJSON(json['internalSubjectiveOpinion']),
    };
}

export function EdgeToJSON(value?: Edge | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        
        'sourceTagId': value.sourceTagId,
        'destinationTagID': value.destinationTagID,
        'sourceTextBoxId': value.sourceTextBoxId,
        'destinationTextBoxId': value.destinationTextBoxId,
        'edgeType': value.edgeType,
        'slack': value.slack,
        'elasticity': value.elasticity,
        'internalSubjectiveOpinion': InternalSubjectiveOpinionToJSON(value.internalSubjectiveOpinion),
    };
}


