/* tslint:disable */
/* eslint-disable */
/**
 * DeepVISS TAG
 * DeepVISS (Deep Vision Interoperability Specification Standard) allows several computer vision solutions to produce, consume and exchange events in the same format.
 *
 * The version of the OpenAPI document: 1.2.0
 * Contact: office@deepviss.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { exists, mapValues } from '../runtime';
/**
 * The object contains the description of an identifier segment
 * @export
 * @interface PermanentIdentifierSegment
 */
export interface PermanentIdentifierSegment {
    /**
     * The encoding used for deserializing the value, before distance and identity functions can be computed
     * @type {string}
     * @memberof PermanentIdentifierSegment
     */
    encoding?: PermanentIdentifierSegmentEncodingEnum;
    /**
     * The index of the segment, so as to guarantee strict ordering of segment comparison
     * @type {number}
     * @memberof PermanentIdentifierSegment
     */
    index?: number;
    /**
     * The weight of the distance in the total distance
     * @type {number}
     * @memberof PermanentIdentifierSegment
     */
    weight?: number;
    /**
     * The hashcode obtained by running a SHA-512 on the binary values of the segments, in their order. 
     * @type {string}
     * @memberof PermanentIdentifierSegment
     */
    assignmentFunction?: PermanentIdentifierSegmentAssignmentFunctionEnum;
    /**
     * The serialized value of the segment
     * @type {string}
     * @memberof PermanentIdentifierSegment
     */
    value?: string;
}

export function PermanentIdentifierSegmentFromJSON(json: any): PermanentIdentifierSegment {
    return PermanentIdentifierSegmentFromJSONTyped(json, false);
}

export function PermanentIdentifierSegmentFromJSONTyped(json: any, ignoreDiscriminator: boolean): PermanentIdentifierSegment {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        
        'encoding': !exists(json, 'encoding') ? undefined : json['encoding'],
        'index': !exists(json, 'index') ? undefined : json['index'],
        'weight': !exists(json, 'weight') ? undefined : json['weight'],
        'assignmentFunction': !exists(json, 'assignmentFunction') ? undefined : json['assignmentFunction'],
        'value': !exists(json, 'value') ? undefined : json['value'],
    };
}

export function PermanentIdentifierSegmentToJSON(value?: PermanentIdentifierSegment | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        
        'encoding': value.encoding,
        'index': value.index,
        'weight': value.weight,
        'assignmentFunction': value.assignmentFunction,
        'value': value.value,
    };
}

/**
* @export
* @enum {string}
*/
export enum PermanentIdentifierSegmentEncodingEnum {
    JsonArray = 'json-array',
    Base64BinaryFloat = 'base64-binary-float',
    Base64BinaryDouble = 'base64-binary-double',
    Base64BinaryInt32 = 'base64-binary-int32',
    Base64BinaryInt64 = 'base64-binary-int64',
    TextAscii = 'text-ascii',
    TextUnicode = 'text-unicode'
}
/**
* @export
* @enum {string}
*/
export enum PermanentIdentifierSegmentAssignmentFunctionEnum {
    HashedFromData = 'hashed-from-data',
    MachineRandomUniform = 'machine-random-uniform',
    MachineTimestamp = 'machine-timestamp',
    MachineIdentifier = 'machine-identifier',
    RemoteTimestamp = 'remote-timestamp',
    RemoteGenerated = 'remote-generated',
    EntityIdentifierLedger = 'entity-identifier-ledger',
    EnforcedUniqueLedger = 'enforced-unique-ledger',
    SequentialEnforcedVolatileLedger = 'sequential-enforced-volatile-ledger',
    SequentialEnforcedPersistentLedger = 'sequential-enforced-persistent-ledger'
}


